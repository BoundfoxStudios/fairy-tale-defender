[{"body":"Die Roadmap beschreibt sehr grob den Ablauf des Projektes und die Punkte, die wir erreichen wollen.\nOft werden Roadmaps auch mit einem Datum versehen, wann ungefähr was fertig sein soll. Auf ein Terminieren verzichten wir hier bewusst, da wir uns die Zeit nehmen, die wir brauchen.\nPhasen In diesem Abschnitt folgt eine sehr grobe Definition, welche Phasen durchlaufen werden. Ein Pfeil markiert, an welcher Stelle wir uns aktuell befinden.\nFindung des Genres: Entscheidung der Community: Tower Defense\nFindung des Themas: Entscheidung der Community: Mittelalter\nFindung des Stils \u003c-\nHier werden wir auf Basis des Themas versuchen, einen grafischen Stil zu finden, an dem sich die kreativen Köpfe orientieren sollen.\nErstellung des Game Design Documents.\nHier halten wir grob fest, was genau wir eigentlich für ein Spiel entwickeln wollen. Hier drin werden wir auch den MVP (siehe weiter unten) definieren.\nImplementierung der Basis-Infrastruktur.\nDas hier wird bereits parallel zum aktuellen “Pfeil” mitlaufen, da diese Basis unabhängig vom Spieltyp ist und bereits implementiert werden kann.\nUmsetzung des MVPs.\nDas bedeutet natürlich, dass hier modelliert, designt, entwickelt, getestet, etc. wird.\nJeden einzelnen Punkt werden wir im Laufe der Zeit weiter und genauer ausarbeiten, sobald wir die jeweilige Phase erreichen.\nNach Punkt 3 können wir uns auch an eine Namensfindung machen.\nAb Punkt 6, also wenn’s vom Spiel quasi was zu sehen gibt, können wir bereits das Spiel in einen Beta-Branch auf Steam deployen, sodass jeder, der dann einen Steam Key hat (wie hier die Verteilung aussieht, müssen wir noch schauen), den aktuellen Stand laden und testen kann.\nMVP Mit einem MVP, kurz für Minimal Viable Product, wird versucht herauszufinden, ob es für ein gewisses Spiel einen Markt bzw. Zielgruppe gibt. Das ist natürlich dann interessant, wenn man mit einem Spiel einen finanziellen Erfolg erreichen möchte. Merkt man durch den MVP, dass sich niemand für das Spiel interessiert, kann es sein, dass die Idee nicht gut ist und man über das Spiel nochmal nachdenken muss.\nIn unserem Fall ist das ein bisschen anders, da wir das Spiel kostenfrei zur Verfügung stellen werden und es vor allem auch um den Lernfaktor geht für jeden, der mitmachen möchte. Daher müssen wir keine “Forschung” betreiben, ob unser Spiel auf einen Markt trifft und einen finanziellen Erfolg bedeuten könnte.\nNichtsdestotrotz beschreibt ein MVP eben die kleinste Umsetzung der Kernidee.\nMVP Tower Defense Ziel des MVPs für ein Tower Defense ist es, einen ersten Game Loop zu erreichen. Dieser könnte wie folgt aussehen.\nSpiel starten (Spieler landet direkt auf einer Map) Spieler sieht einen Weg, links ein Portal, rechts unsere Basis. Gegner spawnen im Interval und laufen den Weg entlang. Spieler kann 1-2 verschiedene Türme bauen. Türme schießen auf den Gegner. Werden alle Gegner besiegt -\u003e Gewonnen Erreichen die Gegner unsere Basis -\u003e Verloren Wenn wir diesen MVP erreicht haben, haben wir bereits einiges umgesetzt.\nNatürlich gibt’s hier viele Dinge noch nicht, Menüs, Optionen, Map-Auswahl, und und und. Das ist zu diesem Zeitpunkt auch noch nicht wichtig und wird nach dem MVP angegangen. Natürlich kann, wenn sich genug beteiligen, auch in der MVP-Phase bereits eine Implementierung von Menüs, Optionen etc. geschehen. Bei gewissen Implementierungen kommt man sich hier ja auch nicht in die Quere.\nWichtig ist, dass das Hauptfokus bei der Umsetzung des Game Loops ist, denn nur mit diesem kann das Spiel letzendlich auch gespielt werden. :)\n","categories":"","description":"Beschreibt den groben Ablauf des Projekts.","excerpt":"Beschreibt den groben Ablauf des Projekts.","ref":"/community-project/docs/roadmap/","tags":"","title":"Roadmap"},{"body":"Wir nutzen als Basis die .NET Standards und folgen diesen weiteren Anpassungen.\nAngepasst und übersetzt vom Unity Open Project.\nCode Bezeichner Beschreibbare und präzise Namen, auch wenn diese länger werden. Lesbarkeit ist wichtiger als kurze Bezeichner. Verwende keine Abkürzungen. Verwende anerkannte Akryonme, z.B. UI oder IO. Präfixe boolsche Variablen mit “Is”, “Has”, “Can”, etc. z.B. CanJump, IsActive. Vermeide das Nummerieren von Namen, z.B. Animator1, Animator2, etc. Verwende sinnvolle Bezeichner, um den Unterschied erkenntlich zu machen, z.B. PlayerAnimator, EnemyAnimator. Groß-/Kleinschreibung camelCase: Erster Buchstabe ist kleingeschrieben, der jeweils erste Buchstabe der Folgewörter ist großgeschrieben.\nPascalCase: Der erste Buchstabe eines jeden Wortes ist großgeschrieben.\nKlassen, Methoden, Enums, Namespaces, öffentliche Felder und Eigenschaften: PascalCase. Lokale Variablen, Methodenparameter: camelCase. Private Felder: camelCase und Unterstrich-Präfix, z.B. _gameControls. Bei privaten Feldern, die serialisiert werden, also ein [SerializeField] haben: PascalCase. Programmierung Halte den Code in englischer Sprache (dict.cc hilft beim Übersetzen), Ausnahme siehe Kommentare Felder und Methoden bleiben private, außer man benötigt öffentlichen Zugriff. Wenn Du Felder im Inspektor sehen willst, aber den öffentlichen Zugriff nicht benötigt, dann verwende [SerializeField] zusammen mit private. Falls Du dann die Warnung erhälst “Field is never assigned to, will always have its default value”, dann mache eine = default Zuweisung Versuche Singletons zu vermeiden, in dem du z.B. ein ScriptableObject (1, 2, 3) implementierst. Vermeide statische Variablen. Vermeide Magic Numbers (“magische Nummer”), z.B. value * 0.08, warum wird hier der Wert mit 0,08 multipliziert? Nutze stattdessen eine Konstante oder ein Feld, um der Zahl einen Namen zu geben. Nutze Namespaces, wie es in C# üblich ist, jeder Ordner ist automatisch ein Namespace. Das Basis-Namespace ist BoundfoxStudios.CommunityProject. Asynchrone Entwicklung / Coroutines Wir setzen im Community-Projekt auf eine externe Bibliothek, sodass wir C# async/await nutzen können: UniTask. Die Bibliothek integriert sich komplett in Unity und ersetzt oft die Nutzung von Coroutines (oder macht deren Nutzung deutlich angenehmer).\nVermeide daher das Implementieren von Coroutinen, falls das ganze auch via async/await implementierbar ist.\nKleine Info am Rande: Bevor es das async/await-Feature in .NET gab, nutzte Unity die Coroutines, um asynchrone Operationen zu ermöglichen. In der Zukunft will Unity selbst mehr und mehr in Richtung async/await gehen und steht dazu auch mit UniTask im Kontakt. Mehr Info siehe ein Blog-Post von Unity selbst -\u003e “Modernizing the .NET Runtime”.\nUnit-Tests Zum Unit-Testen nutzen wir zusätzlich das FluentAssertions-Framework, was das Schreiben und Lesen von Tests angenehmer gestaltet als das von Unity mitgebrachte Assert. Damit es in Unity genutzt werden kann, nutzen wir den Unity-Adapter.\nFormatierung Verwende 1 Tab pro Spalte, keine Leerzeichen. Das gibt einfach jedem die Möglichkeit, den Code visuell so darzustellen, wie man sich wohlfühlt. Kommentare Auch wenn der Code in Englisch gehalten wird, schreibe Deine Kommentare auf Deutsch. Versuche Kommentare zu vermeiden, der Code sollte für sich sprechen. Füge Kommentare dort hinzu, wo es wirklich sinnvoll ist, bspw. wenn eine gewisse Ablaufreihenfolge besteht, die eingehalten werden muss. Nutze VSDoc für Beschreibungen von Klassen, Methoden, etc. Beschreibe jede öffentliche Klasse, Methode und Eigenschaft welchen Zweck sie erfüllt, z.B. /// \u003csummary\u003e /// Diese Klasse kümmert sich um das Abspielen von Kamerafahrten. /// \u003c/summary\u003e Verwende keine #region-Direktiven oder Kommentare, die eine visuelle Trennung erzeugen, wie z.B. //-------. Falls Du sowas brauchst, ist das oft ein Hinweis, dass die Klasse zu viele Zuständigkeiten hat. Scene \u0026 Hierarchy Organisation Nutze leere GameObjects auf der obersten Ebene, um die Hierarchy visuell in logische Bereiche zu trennen, z.B. ----Environment----, ----Managers----. Nutze für diese GameObjects das EditorOnly-Tag, sodass Unity beim Bauen des Projekts diese GameObjects entfernt. Nutze leere GameObjects als Container, sobald Du mehr als 2 zusammenpassende Kind-Objekte hast. Benamung Nutze keine Leerzeichen innerhalb von GameObject-Namen. Nutze PascalCase, z.B. MainDoor, LeverTrigger. Benenne auch Prefab-Instanzen passend in der Hierarchy um. Projektdateien Benamung Gleiche Regeln wie bei Scene \u0026 Hierachy Benenne Deine Objekte so, dass sie auf natürliche Art und Weise gruppiert werden, wenn sie im gleichen Ordner sind. Start beim Namen mit dem “Ding” zu dem es gehört, z.B. PlayerAnimationController, PlayerIdle, PlayerRun, … Wenn es sinnvoll ist, können Objekte so benannt werden, dass ähnliche Objekte zusammenbleiben oder durch ein Adjektiv anders gruppiert werden würden. Beispiel: In einem Ordner mit Requisiten würde man Tische nach dem Schema TableRound und TableRectanngular benennen statt RectangularTable und RoundTable, sodass alle Tische logisch gruppiert werden. Vermeide Dateitypen in Namen, z.B. nutze ShinyMetal statt ShinyMetalMaterial. Ordnerstruktur Beispielstruktur:\n- Assets |- _Game [1] |- Art |- Buildings |- LightningTower |- Materials |- Prefabs |- Environment |- Nature |- Materials |- Prefabs |- Scenes [2] |- Examples [3] |- Menus |- Levels |- ScriptableObjects (Instanzen) [4] |- Scripts [5] |- Events |- ScriptableObjects (Definition) |- UI |- Materials |- ... (eventuelle Drittanbieterintegrationen) _Game-Ordner, das ist unser Root-Ordner für das Spiel. Wir platzieren keinerlei Assets direkt im Assets-Ordner von Unity. Diesen halten wir frei für Drittanbieterintegrationen, z.B. Steam. Im Ordner Scenes legen wir alle Scenen des Spiels ab, logisch gruppiert in weiteren Unterordnern. Im Ordner Examples kannst Du, wenn Du neue Systeme für das Spiel implementierst, eine Beispielszene ablegen, um anderen zu zeigen, wie es funktioniert. Instanzen von ScriptableObjects legen wir separat in diesem Ordner ab. In diesem Ordner legen wir alle Skripte ab, gruppiert nach jeweiligem System. Generell gilt, dass zusammengehörende Dinge in einem Ordner gruppiert werden sollen. Im Zweifel lieber einen Ordner mehr als zu wenig.\n","categories":"","description":"Beschreibung, wie wir unseren Code im Projekt schreiben und strukturieren.","excerpt":"Beschreibung, wie wir unseren Code im Projekt schreiben und …","ref":"/community-project/docs/docs-technical/coding-conventions/","tags":"","title":"Coding Conventions"},{"body":"Continuous Integration Vereinfacht beschreibt CI automatisierte Systeme, die bei Änderungen im Repo loslaufen und diese Änderungen prüfen, ob sie gewisse Dinge einhalten.\nDieses Repo nutzt GitHub Actions zur Umsetzung von Continuous Integration (CI). Alle Workflows finden sich unter .github/workflows. Wir setzen hier stark auf Game CI, die eine Build-Umgebung für Unity bereitstellen.\nIn unserem Fall gibt es mehrere Prüfungen, die loslaufen, sobald ein Push auf develop erfolgt oder ein PR gestellt wird.\nCode Linting: Prüfung, ob Code-Formatierung eingehalten wird. Unit Tests: Starten der Unity Edit- \u0026 Play-Mode-Tests. Export des Players: Es wird versucht, sowohl für Windows, Linux als auch für macOS das Spiel zu exportieren. Sobald alle drei Prüfungen abgeschlossen sind, kann ein PR übernommen werden. Schlägt auch nur eine der Prüfungen fehl, muss der Ersteller des PRs schauen, woran es liegt und diese Fehler beheben.\nUnity Lizenzierung Ein nerviges Problem bei lizenzierter Software ist oft das Aufsetzen von solchen automatischen Systemen, da diese in der Regel eine eigene Lizenz benötigen. Daher funktioniert es in unserem Repo wie folgt:\nPRs und Änderungen an develop werden mit einer Unity Personal License gebaut. Änderungen an main werden mit einer Unity Professional License gebaut (sodass der typische “Made by Unity”-Splashscreen nicht auftaucht). Continuous Delivery Vereinfacht beschreibt Continuous Delivery aus ständige Ausliefern von Änderungen an die Nutzer der Anwendung.\nDies ist bisher im Projekt noch nicht genutzt, soll aber implementiert werden.\nNach jedem Push auf develop soll in Zukunft zuerst der CI-Durchlauf erfolgen. Ist dieser erfolgt, soll die Anwendung paketiert werden und in einen Steam-Deployment-Branch hochgeladen werden.\nWenn alles gut läuft bedeutet das, dass jede erfolgreiche Integration eines PRs innerhalb 1-2 Stunden spielbar auf einem Steam-Branch ist.\n","categories":"","description":"Dokumentation über Continuous Integration \u0026 Continuous Delivery","excerpt":"Dokumentation über Continuous Integration \u0026 Continuous Delivery","ref":"/community-project/docs/docs-technical/ci-cd/","tags":"","title":"Continuous Integration \u0026 Continuous Delivery"},{"body":"\nEs freut uns sehr, wenn wir Dein Interesse geweckt haben, dass Du Dich in irgendeiner Form am Community-Projekt beteiligen möchtest. Schau Dir am besten zuerst das Intro-Video auf YouTube an und lies dann hier weiter. Bitte beachte zudem unseren Code of Conduct, sodass wir hier alle miteinander respektvoll umgehen und eine angenehme Atmosphäre schaffen.\nAktuell haben sich 9 Menschen am Projekt beteiligt!\nWichtig Kleines Vorwort: Wir stehen noch ganz am Anfang dieses Projektes. Wie es für ein neues Projekt üblich ist, ist der Anfang oft am schwierigsten. Es gibt noch keine Strukturen, keine Dinge, bei denen man sich orientieren kann. Wir gehen daher davon aus, dass der Anfang erstmal recht chaotisch ablaufen wird und sich mit der Zeit dann findet. Sei es technisch, kreativer oder organisatorischer Natur. Alles ist noch offen und alles wird nach und nach eine Struktur finden. :) Wer kann sich beteiligen? Jeder Mensch auf dieser Welt. :) Spieleentwicklung ist ein riesiges Thema und es gibt immer was zu tun. Wichtig ist, dass Du Lust und Laune mitbringst und natürlich Spaß an der ganzen Thematik hast.\nWas muss ich können? Es wird (fast) keine Rolle spielen, ob Du ein Anfänger oder bereits ein alter Hase bist. Im Laufe des Projektes werden wir viele Aufgaben haben, sodass jeder etwas für sich finden kann.\nWir alle werden an diesem Projekt sehr viel lernen und das ist auch eines der Ziele - gerade als Tutorial-Kanal auf YouTube.\nLerne Git! Eine Sache ist allerdings für alle Mitmacher wichtig: Die Benutzung von Git, bspw. mit einer Software wie GitHub-Desktop. Auf unserem YouTube-Kanal findest Du dazu ein kleines Video.\nAber: Git hat einen hohen Funktionsumfang, daher solltest Du Dich neben dem Video auf dem Kanal auch selbst mit Git beschäftigen. Über die Suchmaschine Deiner Wahl findest Du unzählige deutschsprachige Tutorials.\nOhne Git kannst Du (fast) nicht am Projekt mitmachen, es ist daher essentiell wichtig, dass Du Dir die Grundlagen aneignest, wie Du an den aktuellen Code kommst und wie ein Pull Request (PR) funktioniert.\nWas kann ich tun? Welche Rollen gibt es? Folgend eine Liste an Ideen, wie man sich an einer Spieleentwicklung beteiligen kann. Wahrscheinlich gibt es noch sehr viel mehr, als hier steht:\nDesigner 3D-Designer Erstellen von Modellen (Umgebung, Gebäude, Fauna und Flora, …) Erstellen von Charakteren (Menschen, Tiere, …) Rigging und Animation 2D-Designer Benutzeroberflächen Icons Marketingbilder (z.B. für die Steam-Seite, Spiel-Logo, etc.) Entwickler Game Code Unity Editor-Erweiterungen Shader/Shader-Graph Sound Musik Effekte Texter Übersetzungen Dokumentation Tutorials Marketingtexte (z.B. für die Steam-Seite) Organisation Game-Designer Ideen entwickeln, ausarbeiten Spieletester Testen und Fehler melden Verbesserungen vorschlagen … :) Verlässlichkeit Dieser Abschnitt ist super wichtig, wenn Du Dich entschließt mitzumachen, in welcher Form auch immer. Jedes Open Source Projekt funktioniert nur so gut, wie die Leute, die mitmachen. Anfangs ist man immer Feuer und Flamme und gerne mal schnell mit dabei. Aber: Dahinter steckt auch viel Arbeit, vor allem für uns, die es organisieren.\nDaher ist das Thema Verlässlichkeit für uns super wichtig. Wenn Du Dich entschließt mitzumachen und eine Aufgabe zu übernehmen (egal, ob diese groß oder klein ist), dann sind für uns in der Organisation zwei Dinge sehr wichtig:\nWir möchten uns darauf verlassen können, dass eine übernommene Aufgabe auch in einer endlichen Zeit fertig wird. Falls Du, man weiß ja nie, wie das Leben spielt, keine Zeit mehr für die Aufgabe hast, dies auch einfach kommunizierst. Niemand wird Dir böse sein, falls es mal nicht klappt und je früher Du es mitteilst, umso einfacher können wir in der Organisation diese Aufgabe neu verteilen. Kommunikation ist an dieser Stelle essentiell. Auch wenn Du Dir z.B. eine Aufgabe zutraust und dann ins Stolpern kommst, weil es doch schwerer ist als gedacht: kein Problem! Schreib in der Community, das gegenseitige Helfen ist genau das, was ein gemeinsames Projekt spannend macht.\nIch möchte … … technisch mitarbeiten (z.B. Entwickler) … visuell mitarbeiten (z.B. 3D-Designer, 2D-Designer) … auditiv mitarbeiten (z.B. Musik, Sound-Effekte) Fühlst Du Dich in dieser Liste noch nicht zu Hause, da Du z.B. eher Spieletester sein möchtest, kein Problem! Dann bist Du zum aktuellen Stand des Projekte noch etwas zu früh dran. Verfolge gerne das Projekt und schau später wieder rein. Sobald es mal “mehr vom Spiel gibt”, werden weitere Rollen sich am Spiel beteiligen können.\nWo finde ich, was es zu tun gibt? Wo sind die Aufgaben? Eine Liste von Aufgaben wirst Du auf der Issue-Seite von unserem Community-Projekt finden. Alternativ kannst Du auch einen Blick auf das Projekt-Board werfen. Das bedeutet aber nicht, dass Du nur an diesen Aufgaben arbeiten kannst. Wenn Du einen Bug gefunden hast oder Dir eine tolle Idee kommt, dann lass uns gerne darüber reden und eventuell machen wir daraus eine neue Aufgabe für Dich.\nHier erneut ein Hinweis zum Thema Verlässlichkeit: Bitte versuche immer nur eine Aufgabe zu übernehmen, diese abzuschließen (bzw. mindestens einen Pull Request zu stellen), bevor Du eine weitere Aufgabe übernimmst.\nWie kann ich eine Aufgabe übernehmen? Sowohl auf der Issue-Seite und auf dem Projekt-Board findest Du alle aktuellen Aufgaben. Alle Aufgaben, die mit Triage markiert sind, bzw. beim Projekt-Board in der Spalte Triage sind, müssen noch vorsortiert werden.\nFür Dich relevant sind daher alle Aufgaben, die nicht mit Triage markiert sind. Wenn Dich eine konkrete Aufgabe interessiert, klicke sie an, um die Dateilseite zu kommen. Lese Dir hier durch, um was es genau geht und stelle gerne Rückfragen, falls Dir eine Information fehlt. Sobald Du Dich entschließt, dass Du diese Aufgabe bearbeiten möchtest, schreibe einen Kommentar in dem folgender Text vorkommt: .meine-aufgabe - Du musst es exakt so schreiben, wie es dort steht, mit dem Punkt am Anfang, alles kleingeschrieben und dem Bindestrich. Sobald Du den Kommentar abgeschickt hast, wird es ca. 30-60 Sekunden dauern, bis GitHub Dir diese Aufgabe zuweist. Ab jetzt kannst Du daran arbeiten. :-)\nFalls Du eine Aufgabe findest, die schon jemand bearbeitet und Du auch dran interessiert bist, dann schreibe gerne einen Kommentar rein und melde Dich am besten kurz auf dem Discord-Server.\nWie kann ich eine Aufgabe wieder abgeben? Falls Dir irgendwas dazwischen kommt, Deine Aufgabe zu bearbeiten (siehe Thema Verlässlichkeit), dann öffnest Du einfach Deine Aufgabe auf GitHub und kannst rechts unter dem Punkt “Assignees” auf “Unassign me” klicken, dann wird Deine Aufgabe wieder zurückgegeben. Zudem wirst Du, falls Du Dich länger nicht um Deine Aufgabe kümmerst, automatisch vom System angeschrieben und daran erinnert.\nIch habe eine Aufgabe fertig, was mache ich damit? Wenn Du eine Aufgabe fertig hast, dann hast Du in der Regel auch eine oder mehrere Dateien verändert, hinzugefügt, gelöscht, etc. Jetzt wirst Du einen Pull Request erstellen, in dem Deine Änderungen sind und auch die Aufgabe verlinkt. Bitte aktiviere beim Erstellen des Pull Requests die Option “Allow edits from maintainers”. Falls alles passt, werden Deine Änderungen von den Ansprechpartnern ins Spiel übernommen werden. Falls etwas nicht passt oder noch was unklar ist, dann wird es entsprechende Rückfragen geben. Eventuell bedeutet das auch, dass Du erneut etwas anpassen musst, damit es dann schlussendlich zum Spiel passt.\nDinge, die Du nicht tun darfst Es gibt ein paar Dinge, die Du wirklich nicht tun darfst, wenn Du mitarbeitest:\nFüge keine Dinge hinzu, die gegen unseren Code of Conduct verstoßen, also z.B. sexualisierte, gewaltverherrlichende Inhalte (Text, Bilder, …), weiteres entnimm bitte dem Code of Conduct. Füge keine Dinge hinzu, die Du nicht selbst erstellt hast oder nicht CC0 lizenziert sind. Auch Code von anderen Projekten darf nicht genutzt werden, außer er ist selbst Open Source. Bei CC0-Lizenzen ist es zwar nicht nötig, dass wir den Original-Autor erwähnen, aber es ist natürlich schön, wenn wir das tun. Wenn Du daher etwas CC0-lizenziertes nutzt, dass Du dies dokumentierst, sodass wir diesen Punkt in den Credits aufnehmen können. Wenn Du Dich nicht an diese grundlegende Dinge hältst, behalten wir uns vor, Dich von der weiteren Zusammenarbeit mit diesem Projekt auszuschließen.\nSchlusswort Wir freuen uns sehr, wenn Du beim Projekt mitmachen möchtest. Es kann auch durchaus vorkommen, dass Dein Beitrag für sich gestellt super ist, aber er leider nicht zum Projekt passt. Schließlich möchten wir sicherstellen, dass das Projekt in die richtige Richtung läuft und wir am Ende etwas spielbares in den Händen halten können.\nDaher hat Boundfox Studios die finale Entscheidung darüber, was im Repository genehmigt wird oder nicht. Falls es je zu so einer Situation kommt, werden die Gründe ausführlich erläutert.\nDas Schluss-Schlusswort Wann immer Du eine Frage hast, nicht weiter kommst oder generell etwas zum Projekt wissen möchtest, komm gerne auf Discord und frag einfach nach. :-)\nUnd jetzt viel Spaß beim Mitmachen!\n","categories":"","description":"Info, wie man beim Community-Projekt mitwirken kann.","excerpt":"Info, wie man beim Community-Projekt mitwirken kann.","ref":"/community-project/docs/contributing/","tags":"","title":"Mitmachen"},{"body":"In dieser Sektion findest Du Dokumentation über bestehende Systeme, die bereits implementiert wurden.\nBitte nutze die Navigation links, um die System-Dokumentationen zu finden.\n","categories":"","description":"Dokumentation wichtiger Systeme.","excerpt":"Dokumentation wichtiger Systeme.","ref":"/community-project/docs/docs-technical/systems/","tags":"","title":"Systeme"},{"body":"Hier findest Du die technische Dokumentation des Community-Projekts.\nWenn Du Dich interessiert, Dich technisch zu beteiligen, also das Entwickeln von Code, dann solltest Du Dir alle Informationen hier durchlesen.\n","categories":"","description":"Sammelpunkt der technischen Dokumentation.","excerpt":"Sammelpunkt der technischen Dokumentation.","ref":"/community-project/docs/docs-technical/","tags":"","title":"Technische Dokumentation"},{"body":"Wenn ich PR gestellt habe, bricht es ab beim “Lint code base”-Check. Linting bedeutet, dass automatisiert eine Software (in diesem Fall dotnet-format) prüft, ob Du den Code so formatiert hast, wie wir es gerne in diesem Projekt hätten. Wenn dies fehlschlägt, dann ist Dein Code noch nicht korrekt formatiert.\nUm das Problem zu behben, musst Du in einer Kommandozeile, die im Ordner CommunityProject geöffnet wurde, folgendes ausführen:\n# Windows: format.bat # Linux/mac:S ./format.sh Wenn der Befehl fertig ist, prüfst Du in GitHub Desktop, ob es geändert Dateien gibt, das sollte jetzt auch der Fall sein. Die geänderten Dateien (und prüfe bitte, ob es wirklich nur Deine Dateien sind) kannst Du nun committen und pushen.\nDurch den Push wird Dein PR erneut geprüft und sollte zumindest bei “Lint code base” kein Problem mehr machen.\nIch erhalte einen Fehler beim Ausführen von format.bat/format.sh. Es scheint, als hättest Du nicht .NET 6 installiert, dort kommt dotnet-format, was von format.bat/format.sh ausgeführt wird, mit. Bitte installiere das .NET 6 SDK\n","categories":"","description":"Häufig gestellte Fragen zum Projekt.","excerpt":"Häufig gestellte Fragen zum Projekt.","ref":"/community-project/docs/docs-technical/faq/","tags":"","title":"Häufig gestellte Fragen"},{"body":"In diesem Glossar sollen einige Begrifflichkeiten definiert werden, die man unter Umständen so noch nicht kennt. Bitte beachte, dass diese Begrifflichkeiten in diesem Glossar oft sehr vereinfacht beschrieben werden, um ein Grundverständnis zu erzeugen. Du solltest natürlich auch die Suchmaschine Deiner Wahl bemühen, um Dein Verständnis zu vergrößern.\nSollte Dir hier ein Begriff fehlen, eröffne gerne ein Issue (“Sonstiges”).\nGit \u0026 Co. Git Allgmeine Versionskontrolle für Softwareentwicklung. GitHub Öffentliches Hosting eines Repositories. GitHub Desktop Software von GitHub zur vereinfachten Nutzung von Git und GitHub. Branch Beschreibt eine Abzweigung innerhalb des Repositories, um verschiedene Entwicklungsstände zu erzeugen. Commit Festsetzen von Änderungen in Git. Kann benannt werden, sodass man nachvollziehen kann, wann welche Änderungen gemacht wurden. Fork \"Verknüpfte\" Kopie eines Repositories. Wird z.B. genutzt um Features, Bugs, etc. zu entwickeln/fixen und dann via Pull Request an das Original-Repository zu übertragen. Repository, Repo Ein unter Versionskontrolle stehender Ordner, in dem Änderungen nachvollzogen werden können. Oder salopp: Ein Git(Hub)-Projekt.\nHier unterscheidet man zwischen einem lokalen Repo und einem remote Repo. Das lokale Repo liegt auf der Festplatte. Das remote Repo liegt z.B. bei GitHub. Über die Git-Kommandos Push und Pull kann das lokale Repo mit dem remote Repo kommunizieren. Pull Das Runterladen von Commits von einem remote Repo in das lokale Repo. Push Das Hochladen von Commits von einem lokalen Repo in ein remote Repo. Pull Request, PR Das Bereitstellen von Änderungen, die in einem Fork gemacht wurden, in das Original-Repo. Game Dev User Interface, UI Die Benutzeroberfläche einer Anwendung. MVP Minimal Viable Product, siehe hier ","categories":"","description":"Auflistung eventueller unbekannter Wörter.","excerpt":"Auflistung eventueller unbekannter Wörter.","ref":"/community-project/docs/glossary/","tags":"","title":"Glossar"},{"body":" TODO Diese Seite ist aktuell noch nicht soweit ausgearbeitet, da es soundtechnisch leider noch nichts zu machen gibt. :) Du bist hier richtig, wenn Du Dich auditiv am Projekt beteiligen möchtest, d.h. Du\nmöchtest Musik komponieren oder möchtest Sound-Effekte für das Spiel erstellen. Worauf muss ich achten? Stereo-Sound. Exportiere Deine Arbeit als .wav-Datei. Wo lade ich meine Ergebnisse hin? Du kannst Deine Ergebnisse im Ordner _contributing/auditory ablegen. Hier erstellst Du einen Ordner mit Deinem Benutzernamen und dort drin je nach Bedarf weitere Ordner (falls Du z.B. an mehrere Stücken gearbeitet hast).\nWichtig ist, dass Du einmal die Original-Datei hochlädst (sodass jemand anders es weiterbearbeiten kann, falls es nötig ist) und bei Sounds einmal einen Export im .wav-Format, sodass wir es dann später in Unity nutzen können. Falls Dein Programm kein .wav exportieren kann (was sehr unwahrscheinlich ist), dann wäre auch .ogg oder .mp3 in Ordnung. .wav wird in jedem Fall allerdings bevorzugt.\nFalls Du Dir unsicher bist, frag gerne auf dem Discord nach.\nBeispiel Wenn Dein Benutzername DerMusterMensch ist und Du einen Plopp-Effekt erstellt hast, dann würdest Du den Ordner _contributing/auditory/DerMusterMensch/PloppEffect anlegen und dort zwei Dateien hochladen:\nPloppEffect.original PloppEffect.wav Was passiert dann? Siehe hier.\nHilfe, ich komme mit Git gar nicht klar Als kreativer Mensch hat man oft noch keinen Berührungspunkt mit dem sehr technischen Git gehabt. Spreche bitte einen Ansprechpartner an, eventuell kann er die Arbeit mit Git für Dich übernehmen.\nFür die Erweiterung Deiner Skills ist’s natürlich cool, wenn Du Dir Git aneignest.\n","categories":"","description":"Info über das Mitmachen im auditiven Bereich.","excerpt":"Info über das Mitmachen im auditiven Bereich.","ref":"/community-project/docs/contributing/auditory/","tags":"","title":"Auditiv (Effekte, Musik) mitmachen"},{"body":"","categories":"","description":"","excerpt":"","ref":"/community-project/categories/","tags":"","title":"Categories"},{"body":"In dieser Dokumentation wirst Du nach und nach alles finden, was zum Community-Projekt gehört.\nAuf der linken Seite findest Du ein Inhaltsverzeichnis, auf der rechten Seite kannst Du Dir den Quelltext von der Dokumentation anschauen. Diese ist, wie das komplette Projekt, auch Open-Source!\nUnten links und rechts findest Du wichtige Links zum Projekt, aber auch hier nochmal:\nGitHub Discord YouTube Twitter Weitere Socials ","categories":"","description":"","excerpt":"In dieser Dokumentation wirst Du nach und nach alles finden, was zum …","ref":"/community-project/docs/","tags":"","title":"Dokumentation"},{"body":"[ Boundfox YouTube Tutorial ]\nWenn Du noch nicht weißt, was ein Event-System ist, dann ist weiter unten eine kleine Erklärung.\nImplementierung Im Code findest Du das Event-System hier. Es besteht aus mehreren Event Channels in Form von ScriptableObjects. Ein Event Channel ist schlicht ein Kanal über den Informationen laufen.\nJeder kann Informationen in ein Event Channel geben und jeder kann diese Informationen mitbekommen. Dadurch das wir hier auf ScriptableObjects setzen, können Sender und Empfänger in unterschiedlichen Szenen sein, was z.B. für das Multi-Scene-Management sehr praktisch ist.\nflowchart LR Action[\"Aktion/Trigger (MonoBehaviour)\"] --\u003e|\"Raise()\"| Event[\"Event (ScriptableObject)\"] EventListener[\"Event Listener (MonoBehaviour)\"] --\u003e|\"Horcht auf\"| Event EventListener --\u003e Response[\"Antwort auf Event\"] Was ist ein Event-System? Der Sinn eines Event-Systems ist es, Systeme zu entkoppeln.\nNehmen wir als Beispiel mal das Leben des Spielers. Wenn der Spieler Leben verliert oder bekommt, möchte man das in der Regel im UI anzeigen. Jetzt könnte der Spieler eine Referenz auf das UI haben (oder auch umgekehrt) und sobald der Spieler Leben verliert oder gewinnt, diese Änderung direkt an das UI übertragen. Weiter möchten wir, dass die Gegner sich anders verhalten, je nach dem, wie viel Leben der Spieler hat. Auch hier könnte jetzt der Spieler alle Gegner kennen und ihnen mitteilen, wenn sich das Leben verändert. Weiter geht’s mit anderen Systemen: Post Processing zum Effekte je nach Leben anzeigen, Audio System, dass entsprechend den Sound ändert etc.\nflowchart LR Spieler --\u003e UI Spieler --\u003e Gegner1 Spieler --\u003e ... Spieler --\u003e GegnerX Spieler --\u003e PostProcessing Spieler --\u003e AudioSystem Wenn der Spieler all diese Systeme direkt kennen würde, nennt man dies auch eine hohe Kopplung. In der Softwareentwicklung versucht man, genau diese hohe Kopplung zu vermeiden. Auch wenn dieses Beispiel hier sehr einfach gehalten ist, führt diese Kopplung langsam aber sicher zu schlecht wartbarem Code. Denn, wann immer man sich die Spieler-Klasse ansieht, sehen wir viele Abhängigkeiten im Code. Jetzt muss jeder Entwickler schauen, was genau diese Abhängigkeiten machen, um zu verstehen, wie die Spieler-Klasse funktioniert. Außerdem hat die Spieler-Klasse viel mehr Verantwortung, als sie eigentlich haben müsste, da sie viele Bereiche der Gesamtanwendung kennt und bearbeitet.\nDas ist in der Softwareentwicklung kein erstrebenswerter Zustand.\nViel mehr wollen wir eine Entkopplung erreichen und hier tritt unser Event-System ein:\nflowchart LR Spieler --\u003e|Leben: 50| EventSystem EventSystem --\u003e|Leben: 50| UI EventSystem --\u003e|Leben: 50| GegnerX EventSystem --\u003e|Leben: 50| PostProcessing EventSystem --\u003e|Leben: 50| AudioSystem Leider sieht es jetzt durch die Grafik so aus, als hätten wir das Problem zum Event-System verschoben, dass jetzt alle anderen kennt. Dem ist aber nicht so. Anstelle dass der Spieler jedes Einzelsystem bearbeitet, nutzt es einfach nur das Event-System und teilt sein aktuelles Leben mit. Was jetzt damit passiert, das ist dem Spieler vollkommen egal. In diesem Moment haben wir alles voneinander entkoppelt. Die Spieler-Klasse hat viel weniger Verantwortlichkeiten, auch für den Entwickler ist es jetzt sehr viel einfacher zu verstehen, da statt viele Einzelsysteme nur noch das Event-System angesprochen wird. Damit haben wir jetzt eine lose Kopplung erreicht.\nEinfach ausgedrückt kann man sich das Event-System als eine Art Walkie-Talkie vorstellen. Jemand teilt seinen Zustand über das Walkie-Talkie mit, ohne zu wissen, wer diese Nachricht hört, ob sich jemand dafür interessiert und was mit der Information passiert.\n","categories":"","description":"Dokumentation des Event-Systems.","excerpt":"Dokumentation des Event-Systems.","ref":"/community-project/docs/docs-technical/systems/event-system/","tags":"","title":"Event-System"},{"body":" Boundfox Studios Community-Projekt Open Source Tower Defense im Mittelalter-Theme.Powered by\nDokumentation GitHub Mitmachen erwünscht Wir freuen uns über jeden, der sich bei der Spielentwicklung beteiligen möchte. Ganz gleich ob Du Entwickler, 3D/2D-Artist, Musik/Effekt-Designer, Ideen-Geber, …, bist - alle sind herzlich willkommen.\nAktuell haben sich 9 Menschen am Projekt beteiligt!\nWeiterlesen …\nDiscord Komm auf den Discord-Server und beteilige Dich an den Diskussionen rund um Features, Implementierung und Asset-Erstellung!\nWeiterlesen …\nYouTube Du interessiert Dich nur für den Fortschritt? Dann abonniere den YouTube-Kanal mit regelmäßigen Updates zum Projekt!\nWeiterlesen …\n","categories":"","description":"","excerpt":" Boundfox Studios Community-Projekt Open Source Tower Defense im …","ref":"/community-project/","tags":"","title":"Boundfox Studios Community-Projekt"},{"body":"Unity ist in der Lage, mehrere Szenen gleichzeitig laufen zu lassen. Dabei können wir als Entwickler bestimmen, wann wir neue Szenen dazu laden oder auch welche wieder entladen. In Unity-sprech ist das ein additives Laden von Szenen.\nDer Ablauf ist aktuell wie folgt:\nWir laden zum Start des Spiels die Initialization-Szene. Sie hat nur ein einziges Objekt mit dem InitializationLoader-Script. Dieses Script startet das eigentliche Spiel, in dem es zwei weitere Szenen lädt: PersistentManagers und das MainMenu. Danach wird die Initialization-Szene entladen. PersistentManagers ist eine Szene, die einmalig geladen wird und während der gesamten Laufzeit vom Spiel nie wieder entladen wird. In dieser Szene liegen Objekte/Manager, die wir das gesamte Spiel über benötigen, z.B. Hintergrundmusik oder das Laden von anderen Szenen (via SceneLoader-Skript). Über ein Event-System können andere Szenen und Objekte mit den PersistentManagers kommunizieren. Für den Fall, dass man in Unity den Play Mode von einer anderen Szene aus startet (was durchaus üblich ist), kümmert sich ein EditorOnly-GameObject darum, diese PersistentManagers zu laden. So, als hätte man das Spiel über die Initialization-Szene gestartet. Dieser Vorgang nennt sich im Community-Projekt “EditorColdStartup”. Die Implementierung des Multi Scene Managements findet sich im Ordner SceneManagement.\nsequenceDiagram autonumber Spielstart -\u003e\u003e Initialization: Lädt activate Spielstart activate Initialization Initialization -\u003e\u003e PersistentManagers: Lädt activate PersistentManagers Initialization -\u003e\u003e PersistentManagers: Event: LoadScene \"MainMenu\" PersistentManagers -\u003e\u003e MainMenu: Lädt Initialization -\u003e\u003e Initialization: Entlädt sich selbst deactivate Initialization Note over PersistentManagers, MainMenu: Typischer Spielablauf...\u003cbr\u003eSpiel wird gespielt... PersistentManagers -\u003e\u003e Spielstart: Spiel beenden deactivate PersistentManagers deactivate Spielstart Vorteile Kein DontDestroyOnLoad notwendig DontDestroyOnLoad (DDOL) bringt einige Nachteile mitsich:\nEs wird oft in Zusammenhang mit dem Singleton-Pattern implementiert. Das bedeutet, dass Unity das Objekt erstellt, das Skript dann prüft, ob es bereits existiert und falls ja, sich automatisch wieder zerstört. Das sind unnötig verbratene Ressourcen. Oft kann DDOL mit einem ScriptableObject ersetzt werden, da DDOL gerne für das Speichern von Laufzeitdaten verwendet wird, die man überall benötigt. Diesen Mechanismus kann man durch Multi Scene Management sehr einfach mit den PersistentManagers erreichen, da diese im Spiel immer zur Verfügung stehen. Kein code-typisches Singleton-Pattern notwendig Oft wird zusammen mit DDOL auch im Code ein Singleton-Pattern implementiert. Das bedeutet, dass das Objekt selbst entscheidet, ob es ein Singleton ist oder nicht. Das führt dann in der Regel dazu, dass man durch seine gesamte Codebase hinweg von überall den Zugriff auf irgendwelche Singletons sieht, was wiederum zu einer hohen Kopplung führt. Warum das schlecht ist, wird im Event-System erklärt.\nDennoch gibt es Anwendungsfälle, bei denen Singletons praktisch sind. Denn das Pattern als solches ist per-se erstmal nicht schlecht, sondern oft dessen Anwendung ist das, was es schlecht macht. Bei Multi Scene Management können wir ein Singleton ganz einfach erreichen, in dem wir ein GameObject in der PersistentManagers-Szene ablegen. Dadurch, dass diese einmalig geladen wird und das gesamte Spiel lebt, haben wir jetzt eine Instanz von einem Objekt, dass wir verwenden können, ergo ein Singleton.\nZudem kommt, dass Singeltons auch oft als Datencontainer, ähnlich wie bei DDOL, genutzt werden. Auch hier haben wir bereits ein Board-Mittel von Unity: ScriptableObjects.\nTypische Anwendungsfälle sind hier z.B. Dinge wie:\nScene Management Hintergrundmusik Analytics Ladebildschirm Nachteile Natürlich bringt das Multi Scene Management auch Nachteile mit sich.\nKomplexität: Gerade für Anfänger, die bisher nur mit einer Szene gearbeitet haben, kann Multi Scene Management zu Beginn sehr komplex wirken. Umdenken: Eigentlich was positives, aber anfänglich eher als Nachteil zu sehen: Man muss umdenken, wie der Code strukturiert ist, da man auf gewisse Dinge eben nicht sofort Zugriff hat, sondern eine Indirektion, z.B. über das Event-System gehen muss. ","categories":"","description":"Dokumentation des Multi-Scene-Managements.","excerpt":"Dokumentation des Multi-Scene-Managements.","ref":"/community-project/docs/docs-technical/systems/multi-scene-management/","tags":"","title":"Multi Scene Management"},{"body":"UI Prefabs Im Community-Projekt nutzen wir ein kleines System, um einfacher Prefabs für das UI finden zu können. Generell liegen die Prefabs im Ordner Prefabs/UI.\nUm komfortabel ein UI zusammenbauen zu können, integrieren wir unsere eigenen Prefabs auch in das Menü von Unity (Rechtsklick in der Hierarchy). Auf diese Art funktioniert das Zusammenstecken von UI-Elementen ähnlich wie bei den Standard-Unity-Elementen.\nDamit das ganze funktioniert, nutzen wir eine Instanz von PrefabManagerSO, dass alle Prefabs sammelt, die in diesem Menü angezeigt werden. Du findest die Instanz unter ScriptableObjects/PrefabManager, oder einfach im Menü auf Community Project -\u003e Select PrefabManager.\nIm Inspektor siehst Du, welche Prefabs verknüpft sind und genutzt werden können.\nWenn Du hier eigene Prefabs hinzufügen möchtest, musst Du den PrefabManager im Code und die Menü-Einträge erweitern.\nIch finde nicht, was ich brauche. Es kann durchaus sein, dass Du UI umsetzen möchtest, aber es dafür noch keine passenden Prefabs findest. Am Besten legst Du diese dann an und fügst wie, wie im Abschnitt zuvor beschrieben, dem PrefabManager hinzu.\n","categories":"","description":"Dokumentation über Prefabs.","excerpt":"Dokumentation über Prefabs.","ref":"/community-project/docs/docs-technical/systems/prefabs/","tags":"","title":"Prefabs"},{"body":"Du kannst komfortabel neue Szenen anlegen, wenn Du in Unity über das Menü File -\u003e New Scene gehst. Dort findest Du im Dialog zwei Templates, die vom Community-Projekt stammen:\nMenu Szene Level Szene Wähle die Menu Szene, wenn Du ein neues Menü anlegen möchtest. Darunter zählen alle FullScreen-Menüs, z.B. MainMenu, Optionen, Credits.\nWähle die Level Szene, wenn Du ein neues Leven anlegen möchtest.\n","categories":"","description":"Dokumentation der Scene Templates.","excerpt":"Dokumentation der Scene Templates.","ref":"/community-project/docs/docs-technical/systems/scene-templates/","tags":"","title":"Scene Templates"},{"body":"","categories":"","description":"","excerpt":"","ref":"/community-project/tags/","tags":"","title":"Tags"},{"body":"Inhaltsverzeichnis Du bist hier richtig, wenn Du Dich für die Entwicklung interessierst, d.h. Du\nentwickelst Code für das Spiel, entwickelst Erweiterungen für den Unity-Editor, möchtest bestehende Bugs im Spiel beseitigen und/oder möchtest mit Shadern bzw. dem Shader-Graph visuellen Pepp hinzufügen (siehe auch hier) Worauf muss ich achten? Lies Dir die Technische Dokumentation durch. Du musst die korrekte Unity-Version installieren, das ist aktuell Unity 2021.3.9f1. Schaue gerne hier nach, welche Version im Projekt eingesetzt wird, falls vergessen wurde, dieses Dokument zu aktualisieren. Um Unity in dieser Version zu installieren, klicke hier, wenn Du den Unity Hub installiert hast. Alternativ, schaue gerne hier auf der Unity-Seite nach der Version. Unity tendiert gerne dazu, dass es Dinge mitändert, die man nicht oder vermeintlich nicht angefasst hat. Konzentriere Dich daher generell nur auf Deine Aufgabe und prüfe in Git, ob Du auch nur die Sachen committest, die Du auch wirklich geändert hast. Was soll ich nicht tun? Bitte mache folgende Dinge nicht oder nur nach Rücksprache mit einem Ansprechpartner:\nAktualisierung der Unity-Version. Neues Package dem Projekt hinzufügen. Bestehendes Package aktualisieren. Lösche keine Assets oder Szenen, die nicht unmittelbar mit Deiner Aufgabe zu tun haben. Refactoring, Rename kann in Ordnung sein. Füge keine Test-Szenen oder Test-Scripte hinzu. Du kannst diese gerne für Dich erstellen, aber committe und pushe sie nicht. Nutze nicht den alten Unity-Text. Wir setzten ausschließlich auf TextMeshPro. Nutze nicht das alte Unity Input. Wir nutzen ausschließlich das neue Unity Input System. Wo lade ich meine Ergebnisse hin? Im Gegensatz zur kreativen Mitarbeit, arbeitest Du als als Techniker direkt am Unity-Projekt und machst dort Deine Änderungen.\nWas passiert dann? Siehe hier.\nHilfe, ich komme mit Git gar nicht klar Als technischer Mitwirkender musst Du Dir Git soweit aneignen, dass Du es für das Projekt nutzen kannst. :)\nFrag gerne auf dem Discord nach, wenn Du so gar nicht weiter kommst.\n","categories":"","description":"Info über das Mitmachen im technichen Bereich.","excerpt":"Info über das Mitmachen im technichen Bereich.","ref":"/community-project/docs/contributing/technical/","tags":"","title":"Technisch mitmachen"},{"body":"Du bist hier richtig, wenn Du Dich visuell am Projekt beteiligen möchtest, d.h. Du\nmodellierst 3D-Modelle, erstellst 2D-Grafiken, -Icons, möchtest mit Shadern bzw. dem Shader-Graph visuellen Pepp hinzufügen (siehe auch hier) Worauf muss ich achten? 3D Quasi Low Poly: Wir machen im Projekt nicht super harte Low Poly Umsetzung, aber eben auch kein High Poly. Versuche Polys zu vermeiden, wo Du keine benötigst und nutze gerne dort ein paar mehr, wo es benötigt wird. Bitte achte darauf, dass alle Pivots korrekt gesetzt sind, gerade bei Dingen, die animiert werden sollen oder von Dir animiert wurden. Das Pivot vom Gesamtmodell soll unten in der Mitte des Modells sein. Orientierung an den Unity-Achsen: X-Achse: nach rechts\nY-Achse: nach oben\nZ-Achse: nach vorne\nWenn Du die Achsenorientierung prüfen möchtest, geht das leider nur mit Unity. Hierzu kannst Du Dir irgendeine Unity-Version installieren, ein neues leeres Projekt erstellen, Deine .fbx Datei ins Projekt ziehen und dann in der Scene ablegen.\n(Originalbild vom Unity Open Game “Chop Chop”)\nSkalierung: 1 Blender Unit = 1 Meter = 1 Unity Unit. Wenn wir Dein Modell in Unity importieren, muss es mit einem 1/1/1 Scaling bereits die korrekte Größe haben. Farben bzw. Farb-Palette muss sich im Laufe des Projektes noch finden. Benutze bitte keinerlei Texturen. Bitte beachte, dass die Shader Deiner Modellierungssoftware nicht mit Unity kompatibel sind. D.h. im Idealfall benötigt Dein Modell keinen eigenen Shader. Falls Du allerdings, Ausnahmen bestätigen die Regel, ein Modell/Aufgabe hast, die einen eigenen Shader benötigt, muss dieser Shader in Unity entwickelt werden. Du kannst ihn zwar in Deiner Modellierungssoftware auch erstellen, er dient dann allerdings nur als Referenz für die Unity-Shader-Entwicklung. Benenne Deine Meshes, Animationen etc. korrekt (und auf Englisch, dict.cc hilft beim Übersetzen), denn niemand weiß, was Cube 1 und Animation 3 nachher wirklich ist. Einfache Modelle sollten aus nur einem Mesh bestehen. Exportiere Deine Modelle als .fbx. 2D Dein Bild sollte so klein wie möglich und so groß wie nötig sein. Farben bzw. Farb-Palette muss sich im Laufe des Projektes noch finden. Wenn Du Bilder für die Benutzeroberfläche erstellst, sollte dieses in der Regel ein sogenanntes “9-slicing Sprite” sein, siehe hierzu die Dokumentation bei Unity. Es handelt sich hier um eine Standard-Technik, daher findest Du mit diesem Begriff einiges mehr über die Suchmaschine Deiner Wahl. Exportiere Deine Arbeit als .png. Wo lade ich meine Ergebnisse hin? Du kannst Deine Ergebnisse im Ordner _contributing/visual ablegen. Hier erstellst Du einen Ordner mit Deinem Benutzernamen und dort drin je nach Bedarf weitere Ordner (falls Du z.B. an mehrere Modellen gearbeitet hast).\nWichtig ist, dass Du einmal die Original-Datei hochlädst (sodass jemand anders es weiterbearbeiten kann, falls es nötig ist) und Dein 3D-Modell als .fbx oder Deine 2D-Arbeit als .png.\nBitte achte auch darauf, dass Deine Dateien bereits optimiert sind, unnötige Sachen entfernt sind, etc. Original-Dateien tendieren oft dazu, recht schnell groß zu werden. Git und große Dateien sind nicht unbedingt Freunde, je mehr Du daher optimierst, umso besser.\nFalls Du Dir unsicher bist, frag gerne auf dem Discord nach.\nBeispiel Wenn Dein Benutzername DerMusterMensch ist und Du ein Baum-Modell erstellt hast, dann würdest Du den Ordner _contributing/visual/DerMusterMensch/Baum anlegen und dort zwei Dateien hochladen:\nBaum.blendfile Baum.fbx Was passiert dann? Siehe hier.\nHilfe, ich komme mit Git gar nicht klar Als kreativer Mensch hat man oft noch keinen Berührungspunkt mit dem sehr technischen Git gehabt. Spreche bitte einen Ansprechpartner an, eventuell kann er die Arbeit mit Git für Dich übernehmen.\nFür die Erweiterung Deiner Skills ist’s natürlich cool, wenn Du Dir Git aneignest.\n","categories":"","description":"Info über das Mitmachen im visuellen Bereich.","excerpt":"Info über das Mitmachen im visuellen Bereich.","ref":"/community-project/docs/contributing/visual/","tags":"","title":"Visuell (3D, 2D) mitmachen"}]